* [JAVA]
  * [Java와 C++의 차이점](#Java와-C++의-차이점)
  * [Java언어의 장단점](#Java언어의-장단점)
* [String, StringBuffer, StringBuilder의 차이점](#String,-StirngBuffer,-StringBuilder의-차이점)

## Java와 C++의 차이점

### 1. 상속

JAVA는 C++보다 단순한 상속 체계를 지원한다.
첫째, **C++은 다중 상속을 지원하고 JAVA는 그렇지 않다.** 여기서 '다중 상속'이라 함은, 하나의 클래스가 두 개 이상의 클래스를 상속하는 것을 지칭한다.
다중 상속을 지원하는 언어에서는 [다이아몬드 문제(Diamond Problem)](#https://codingcoding.tistory.com/517)가 발생하는데, C++에서는 다이아몬드 문제를 회피할 수 있는 기능을 제공한다. 
물론 JAVA에서는 애초에 발생할 일이 없다.

둘째, **C++은 friend 키워드를 지원하고 JAVA는 그렇지 않다.** 특정 class에 friend 키워드를 붙여서 클래스 혹은 함수를 선언해 놓으면, 명명된 클래스와 함수는 그 class의 private, protected 영역에 접근할 수 있다. 하지만, 이 방법은 **객체의 은닉성을 파괴**하므로 정말 특수한 경우가 아니면 **사용을 지양**한다.

셋째, **JAVA는 Interface를 지원하고 C++은 그렇지 않다.** 다중 상속이 지원되지 않는 JAVA는 Interface를 통해 다중 상속을 어느 정도 흉내낼 수 있다. JAVA에서는 하나의 Class가 여러 개의 Interface를 Implements할 수 있다. **interface는 상수와 추상 메소드로만 구성**되어 있으므로, **여러 개의 Interface를 Implement하더라도, 다이아몬드 문제를 발생시키지 않는다.**

```
요약
1. C++은 다중 상속을 지원하나, JAVA는 지원하지 않음
2. C++은 friend 키워드를 지원하나, JAVA는 지원하지 않음 (하지만, C++에서도 friend 키워드는 은닉성 이슈로 사용 자제)
3. JAVA는 다중 상속을 지원하지 않는 대신, Interface를 지원한다.
```

### 2. 메모리 처리

첫째, **JAVA는 객체를 메모리의 Heap 영역에만 할당할 수 있으나, C++의 경우 Heap과 Stack 영역 모두에 할당이 가능하다.** C++에서 new 키워드를 통해 객체를 생성하면 Heap 영역에 객체가 할당되고, 일반적인 변수 선언 방식을 택하면 Stack 영역에 할당된다. **JAVA에서는 일반적인 변수 선언 방식으로 객체를 생성할 수 없다.** *(Heap과 Stack의 비교)[https://opennote46.tistory.com/67]*

둘째, **JAVA는 메모리(Heap 영역) 해제가 자동으로 이루어지지만, C++은 프로그래머가 수동으로 해야 한다.** JAVA에서는 Garage Collector가 미사용 객체 등의 자원을 자동으로 해제하며, **프로그래머는 수동으로 GC를 조작할 수 없다.** 하지만, C++에서는 **Destructor(소멸자)**를 통해 메모리 해제가 가능하다.

```
요약
1. C++은 객체를 Heap과 Stack에 모두 할당 가능, JAVA는 Heap에만 가능
2. JAVA는 메모리 해제가 자동(Garbage Collector), C++은 수동
```

### 3. 문법 및 기능

첫째, **C++에서는 연산자 오버로딩을 지원하지만, JAVA는 그렇지 않다.** 연산자 오버로딩은 단어 그대로 연산자를 재정의 하여 활용한다는 것이며, '객체 간 연산'에 활용할 수 있다. (ex. * 연산을 재정의하여 객체와 객체를 * 연산할 수 있다.) JAVA는 만들어질 때부터 이러한 연산자 오버로딩을 지원하지 않는 방향으로 개발되었다고 한다.

둘째, **JAVA는 익명 클래스(Anonymous Class)를 지원하지만, C++은 그렇지 않다.** 익명클래스는 JAVA에서 지원하는 기능으로, 이름이 없는 클래스이다. 인터페이스의 메소드 중 하나만 재정의하고 싶을 떄 자주 사용되며, 클래스의 선언과 객체의 생성이 동시에 이루어지는 형태를 띄고 있다. JAVA는 익명클래스를 통해 '함수형 프로그래밍'의 형태를 어느 정도 흉내낼 수 있다.

셋째, **JAVA는 동적바인딩(Dynamic Binding)을 택하고 있지만, C++은 정적바인딩(Static Binding)을 택한다.** 하지만, C++이 정적바인딩만 지원하는 것은 아니고, **virtual 키워드**를 통해 동적바인딩을 지원한다. *(바인딩)[https://medium.com/pocs/%EB%B0%94%EC%9D%B8%EB%94%A9-binding-4a4a2f641b27]*

```
요약
1. C++은 연산자 오버로딩 지원, JAVA는 지원하지 않음
2. JAVA는 익명클래스 지원(함수형 프로그래밍을 어느정도 구현), C++은 지원하지 않음
3. JAVA는 동적바인딩, C++은 정적바인딩(virtual 키워드로 동적바인딩 가능함)
```

|  기능      | C++ | JAVA|
|--------|---------|-----------|
|다중 상속 | 가능 | 불가 |
|Friend Class| 가능 | 불가 |
|Interface| 불가 | 가능 |
|객체 생성| Heap, Stack | Heap |
|Garbage Collection| 수동| 자동|
| 연산자 오버로딩 | 가능 | 불가|
|익명 클래스 | 불가 | 가능 |
|바인딩 방식 | 동적 | 동적, 정적 |


## JAVA 언어의 장단점

먼저, JVM에 대한 설명을 하자면,
### JVM(Java Virtual Machine)이란?

자바는 완전한 기계어가 아니라 바이트코드이기 때문에 이를 해석하고 실행할 수 있는 가상 운영체제가 필요한데, 이것이 JVM이다.
운영체제별로 따로 실행하고 관리하는 방법이 다르기 때문에 별도로 운영체제와 자바 프로그램을 실행하고 관리하는 것이 아니라, 중계하는 JVM을 두어서 여러 운영체제에서 동일한 실행 결과를 나타내도록 설계한다. 즉, **한 번 작성하면 어디서든 사용 가능하다는 장점을 가진다.**


- 장점
  - 운영체제에 독립적이다.(이식성이 높다)
    - 자바 응용 프로그램은 운영체제나 하드웨어가 아닌 JVM하고만 통신하고, JVM은 자바 응용 프로그램으로부터 전달받은 명령을 해당 운영체제가 이해할 수 있도록 변환하여 전달한다.
    - '한 번 작성하면 어디에서나 실행된다. (Write once, run anywhere)'
  - 객체지향 언어이다.
    - 객체 지향 프로그래밍(Object-Oriented Programming, OOP)은 컴퓨터 프로그래밍의 패러다임 중 하나이다.
    - 객체 지향 프로그래밍은 프로그램을 유연하고 변경이 용이하게 만들기 때문에 대규모 소프트웨어 개발에 많이 사용된다.
    - 프로그래밍을 더 배우기 쉽게 하고 소프트웨어 개발과 보수를 간편하게 하며, 보다 직관적인 코드 분석을 가능하게 하는 장점을 갖고 있다.
    - 하지만, 지나친 프로그램의 객체화 경향은 실제 세계의 모습을 그대로 반영하지 못한다는 비판을 받기도 한다.
  - 자동 메모리 관리(Garbage Collection)
    - Garbage Collector가 자동으로 메모리 관리를 해주기 때문에 프로그래머는 따로 메모리를 관리하지 않아도 된다.
    - 자동 메모리 관리는 다소 비효율적인 면도 있지만, 프로그래머가 보다 프로그래밍에 집중할 수 있도록 도와준다.
  - 오픈 소스이다.
    - OpenJDK가 오픈소스이다.
    - JAVA는 오픈소스 언어이기에 자바를 사용하는 라이브러리 또한 오픈소스가 많다.
    - 고급기능을 구현한다면 코드를 직접 작성할 경우, 노력과 시간이 필요하고 안정성을 보장할 수 없지만, 검증된 오픈소스는 개발시간을 단축시킬 수 있다.
  - 멀티쓰레드를 쉽게 구현할 수 있다.
    - 멀티쓰레드는 하나의 프로그램이 동시에 하나 이상의 처리(process)를 수행하는 것을 의미한다.
    - JAVA는 사용자가 쓰레드를 편리하게 작성하여 사용할 수 있도록 쓰레드와 관련된 라이브러리 클래스를 제공하고 있고, JVM은 멀티쓰레드를 동시에 처리한다.
    - 일반적으로 자바로 작성된 Application은 여러 개의 클래스로 구성되어 있다. JAVA는 다이나믹 로딩을 지원하기 때문에 실행 시 모든 클래스가 로딩되지 않고 필요한 시점에 클래스를 로딩하여 사용할 수 있다.

- 단점
  - 비교적 속도가 느리다.
    - JAVA는 하드웨어에 맞게 완전히 컴파일된 상태가 아니고, 실행 시 해석(Interpret)되기 대문에 속도가 느리다는 단점이 있다.
    - 그러나 바이트코드(byte code)를 하드웨어의 기계어로 변환해주는 JIT 컴파일러와 Hotspot(향상된 최적화 기술)과 같은 기술 적용으로 JVM 성능이 향상되어 속도문제가 상당히 개선되었다.
  - 예외 처리가 불편하다.
    - 프로그램을 돌리다가 프로그램이 의도된 대로 동작하지 않은 상황에서 예외를 발생시켜 처리할 수 있다. 하지만, JAVA는 다른 언어와는 달리 프로그래머 검사가 필요한 예외가 등장하면 무조건 프로그래머가 선언해줘야 한다. 그렇지 않으면 컴파일조차 되지 않는다.
    - JAVA에서 제공하는 Iterator 인터페이스에서는 throws 선언이 없기 때문에 Iterator를 구현받았을 때 명시적으로 예외를 던질 수 없다. 이 상황을 해결하기 위해 RuntimeException 계열을 쓸 수 밖에 없는 상황이 된다.
    

## JAVA의 접근 제어자의 종류와 특징

| 접근 제어자   | 표시 | 설명 |
|--------|---------|-----------|
| public | + | 어떤 클래스의 객체에서든 접근 가능 |
| private | - | 이 클래스에서 생성된 객체들만 접근 가능 |
| protected | # | 이 클래스와 동일 패키지에 있거나, 상속 관계에 있는 하위 클래스의 객체들만 접근 가능 |
| package(default) | ~ | 동일 패키지에 있는 클래스의 객체들만 접근 가능 |


## OOP의 4가지 특징
OOP는 컴퓨터 프로그래밍의 패러다임 중 하나이다.
절차지향 언어(C)에서는 각 명령어의 실행 순서를 기반으로 바라보지만, OOP는 데이터와 이를 처리하는 루틴을 하나의 "독립된 객체"로 바라본다.
**기존에 만들었던 내용**을 쉽게 상속, 다형성 등을 이용해서 **재사용 가능**하다.

### 1. 추상화(Abstraction)

구체적인 사물들의 공통적인 특징을 파악해서 이를 하나의 개념(집합)으로 다루는 수단이다.
*각 개체의 구체적인 개념에 의존하지 말고 추상적 개념에 의존해야 설계를 유연하게 변경할 수 있다.*

- 구체적인 개념에 의존하는 경우
``` java
swich(자동차 종류)
case 아우디: // 아우디 엔진 오일을 교환하는 과정을 기술
case 벤츠: // 벤츠 엔진 오일을 교환하는 과정을 기술
case BMW: // BMW 엔진 오일을 교환하는 과정을 기술
... 새로운 종류의 자동차가 나오면 계속해서 추가
end switch
```

- 추상적인 개념에 의존하는 경우
``` java
void changeEngineOil(Car c) {
 c.changeEntineOil(); // 추상 메소드
}
```
 - changeEngineOil의 인자로 아우디, 벤츠의 추상화 개념인 "Car"을 사용한다.
 - 이 코드는 어떤 새로운 종류의 자동차가 나와도 **변경할 필요가 없다.**
 - '다형성'의 원리에 따라 각 구체적인 클래스에서 오버라이드된 메소드 changeEngineOil을 호출한다.


### 2. 캡슐화(Encapsulation)

cf. SW 공학에서 요구사항 변경에 대처하는 고전적인 설계 원리
  - 높은 응집도와 낮은 결합도를 유지할 수 있도록 설계해야 요구사항을 변경할 때 유연하게 대처할 수 있다.
  1. 응집도(Cohesion) : 클래스나 모듈 안의 요소들이 얼마나 밀접하게 관련되어 있는지
  2. 결합도(Coupling) : 어떤 기능을 실행하는 데 다른 클래스나 모듈에 얼마나 의존적인지
  
캡슐화는 **낮은 결합도**를 유지할 수 있도록 해주는 객체지향 설계 원리다.
- 캡슐화는 **정보 은닉**을 통해 높은 응집도와 낮은 결합도를 갖도록 한다.
  - 정보 은닉(information hiding)
    - 필요가 없는 정보는 외부에서 접근하지 못하도록 제한하는 것
    - private 키워드
  - 정보 은닉이 왜 필요할까?
    - 한 클래스의 변경이 발생하면, 변경된 클래스에 의존하는 다른 클래스도 변경해야 한다.
    
### 3. 일반화(Generalization)

여러 개체들이 가진 공통된 특성을 부각시켜 하나의 개념이나 법칙으로 성립시키는 과정이다.
- 일반화 관계는 객체지향 프로그래밍 관점에서는 *상속 관계*라고 한다.

### 4. 다형성

서로 다른 클래스의 객체가 같은 메세지를 받았을 때 각자의 방식으로 동작하는 능력

(OOP 4가지 특성)[https://gmlwjd9405.github.io/2018/07/05/oop-features.html]


## OOP의 5대 원칙(SOLID)
- S: 단일 책임 원칙(SRP, Single Responsibility Principle)
  - 객체는 단 하나의 책임만 가져야 한다.
- O: 개방-폐쇄 원칙(OCP, Open Closed Principle)
  - 기존의 코드를 변경하지 않으면서 기능을 추가할 수 있도록 설계가 되어야 한다.
- L: 리스코프 치환 원칙(LSP, Liskov Substitution Principle)
  - 일반화 관계에 대한 이야기며, 자식 클래스는 최소한 자신의 부모 클래스에서 가능한 행위는 수행할 수 있어야 한다.
- I: 의존 역전 원칙(DIP, Dependency Inversion Principle)
  - 의존 관계를 맺을 때 변화하기 쉬운 것 또는 자주 변화하는 것보다는 변화하기 어려운 것, 거의 변화가 없는 것에 의존하라는 것이다.
- D: 인터페이스 분리 원칙(ISP, Interface Segregation Principle)
  - 인터페이스를 클라이언트에 특화되도록 분리시키라는 설계 원칙이다.
 
 

---
## String, StringBuffer, StringBuilder의 차이점

- 먼저, String과 다른 두 클래스(StringBuffer, StringBuilder)의 차이점을 알아보면 String은 immutable(불변)하고 다른 두 클래스는 mutable(변하기 쉬움)하다는 것이다.

### 1. String

문자열을 사용할 때 가장 많이, 보편적으로 이용되는 클래스다.
String 객체는 한 번 생성되면 할당된 메모리 공간이 변하지 않는다. 

``` java
String str = new String("example");
```
위와 같이 쓰거나, 리터럴 문자열로 바로 대입할 수도 있다. 
제일 많이 쓰는 클래스인 만큼, 빠르고 쉽게 문자열을 할당하고 사용할 수 있다는 장점이 있다.
하지만, 이 String 클래스의 단점은 **문자열에 변화를 줄 때 시간 소모가 너무 많이 든다**는 것이다.
String 객체에 할당된 메모리 공간이 변하지 않기 때문에 +연산자 혹은 concat 메소드를 통해 다른 문자열을 붙이면 새로운 String 객체를 만든 후, 새 String 객체에 연결된 문자열을 저장하고, 그 객체를 참조한다.
(즉, String 클래스 객체는 Heap 메모리 영역(가비지 컬렉션이 동작하는 영역)에 생성되며, 한 번 생성된 객체의 내부 내용을 변화시킬 수 없다. 기존 객체가 제거되면 Java의 가비지 컬렉션이 회수한다.)

``` java
for(int i = 0; i < 1000000; i++){
  str += "a";
}

System.out.println(str);
```

위의 코드에서 답은 aaaa... 이다. 여기서 주목해야 할 부분은 "+="이다. Concatenation 작업은 메모리 초기화와 생성을 이루며 진행되기 때문에 Concatenation 작업이 많거나 loop 내에 있으면 성능이 안 좋아진다.
따라서 자세히 보면 str += "a" 는 str 뒤에 a를 붙이는 것이 아니라 str 뒤에 a를 붙인 new String을 할당하는 것이다.
concatenation 연산이 16만번 이상이 되면 실행 시간이 10초가 넘어간다고 하니, 해당 연산이 많을 경우에는 사용하지 않는 것이 좋다. (위의 코드 실행 시 1분!)

### 2. StringBuffer + StringBuilder

StringBuffer와 StringBuilder는 위의 String과 다르게 가변적(mutable)이다.

따라서 두 클래스 모두 문자열에 변화를 주면 해당 문자열에서 변경시킬 수 있다.

``` java
StringBuilder string = new StringBuilder();
for(int i = 0; i < 1000000; i++){
  string.append("a")
}

System.out.println(string);
```

위와 같이 사용하면 되고, StringBuffer도 비슷하게 사용하면 된다.
String과는 다르게 append 시 "a"가 붙은 새로운 문자열을 생성하는 것이 아니라, 기존 문자열에 "a"를 붙인다. 그래서 String에 비해 메모리 파기와 생성에 드는 시간이 단축된다.

### 3. StringBuilder vs StringBuffer

 두 클래스는 모두 mutable 특성을 가지고 있지만, 두 클래스의 차이점은 **thread-safe 지원 여부**이다.
 **StringBuffer는 String과 같이 thread-safe의 특성을 가진다.** 즉, 멀티쓰레드 환경에서 동기화를 지원한다.
 반대로, StringBuilder는 멀티쓰레드에서 쓰기엔 좋지 않다. 하지만, **StringBuilder는 멀티쓰레드가 아닌 환경**에서 StringBuffer보다 **더 빠른 성능**을 보인다.
 
 - 정리
 
|     | String | StringBuilder | StringBuffer|
|-----|--------|--------------|---------------|
|변화 특성| immutable | mutable | mutable |
|Thread-safe 지원 여부 | O | O | X |

따라서 단일쓰레드 환경에서 단순한 성능만 놓고 본다면, 연산이 많은 경우 **StringBuilder >> StringBuffer >> String**이라고 볼 수 있다.
(StringBuffer는 동기화 관련 처리로 인해 StringBuilder에 비해 성능이 좋지 않다.)
