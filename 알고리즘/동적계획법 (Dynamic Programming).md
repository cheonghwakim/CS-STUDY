### 동적계획법 (Dynamic Programming)

#### 피보나치 수열

동적 계획법의 등장 배경은 피보나치 수열을 통해 알 수 있다.

피보나치 수열은 보통 재귀를 통해 표현한다. 

```java
// 피보나치 수열의 n번째 수를 구하는 함수
int fibo(int n)
  {
    if (n <= 2)
      return 1;
    else
      return fibo(n - 1) + fibo(n - 2);
   }
```

`fibo(6)`의 실행 과정

![img](https://media.vlpt.us/images/chelsea/post/627c053e-8a71-48e7-b0b2-7b8d327963a2/%E1%84%8C%E1%85%A2%E1%84%80%E1%85%B1%E1%84%91%E1%85%B5%E1%84%87%E1%85%A9.gif)
`fibo(4)`의 연산이 두 번, `fibo(3)`의 연산이 세 번 진행되는 것을 볼 수 있다. 



#### 동적 계획법의 등장

위의 예시처럼 이미 했던 연산이 반복되는 결점을 보완하기 위해서 동적 계획법(Dynamic Programing, DP)이 고안되었다. 처음 진행되는 연산은 기록해 두고, 이미 진행했던 연산이라면 기록되어 있는 값을 가져온다.

```java
int memo[100] = new int[100];

int fibo(int n)
{
  if (n <= 2) 
    return 1;
  if (memo[n] == 0)
    memo[n] = fibo(n - 1) + fibo(n - 2);
  return memo[n];
}
```

`memo`라는 배열을 생성하고 연산된 값들이 저장된다. `n`이 2 이하일 경우 1을 반환하고, 그 이상일 경우 `memo[n]`에 연산 값이 없는지 검사한다. 없을 경우, 새로 연산해서 `fiboData[n]`에 값을 저장하고, 반환한다. 만약 연산 값이 존재한다면 바로 `memo[n]`을 반환한다. 



#### 개념

동적 계획법은 문제를 풀 때 하나의 문제를 여러 하위 문제로 나누어 풀고, 그것들을 결합해서 최종 목적에 도달하는 방식의 알고리즘



#### 메모이제이션 (Memoization)

하위 문제를 해결할 때 **그 해결책을 저장해 두고, 똑같은 문제가 발생했을 때 저장되어 있던 해결책**을 가져온다. 이렇게 동일한 문제를 반복해야 할 경우, 한 번 계산된 결과를 저장해 두었다가 활용하는 방식으로 중복 계산을 줄이는 것을 **메모이제이션(Memoization)**이라고 한다.



#### Top-Down

문제 풀이가 위에서 아래로 진행되는 것

```java
int memo[100] = new int[100];

int fibo(int n)
{
  if (n <= 2) 
    return 1;
  if (memo[n] == 0)
    memo[n] = fibo(n - 1) + fibo(n - 2);
  return memo[n];
}
```

`fibo(6)`을 호출하게 되면 `fibo(6)`부터 작은 수를 호출하며 가장 작은 수까지 도달한다. 메모이제이션 사용



#### Bottom-Up

문제 풀이가 아래에서 위로 진행되는 것

```java
int fibo(int n)
{
  memo[0] = 0;
  memo[1] = 1;
  for (int i = 2; i <= n; i++)
    memo[i] = memo[i - 1] + memo[i - 2];
  return memo[n];
}
```

 `for`문 내에서 `fiboData[2]`부터 `fiboData[6]`까지 계산해 나간다. 이렇게 처음 값부터 계산해 최종 값까지 계산해 내는 것이 BOTTOM-UP 방식



#### 장점과 단점

동적 계획법은 모든 방법을 일일이 검토하여 최적의 해를 찾아내는 방식의 알고리즘. 

여기서 **그리디 알고리즘(탐욕 알고리즘)**과 대비된다. 그리디 알고리즘은 **모든 해를 구하지 않고 순간마다 그 순간에서의 최적의 해를 찾는 방식**이다. 

하지만 동적 계획법은 **모든 방법을 검토해 보고 결과적으로 효율적인 값을 택한다**. 그런 면에서 **동적 계획법은 그리디 알고리즘에 비해 시간이 오래 걸리지만, 결과적으로는 항상 최적의 해를 구할 수 있다는 이점을 가지고 있다.**

