# 운영체제

* [컴파일러와 인터프리터의 차이](#컴파일러와-인터프리터의-차이)
* [프로세스와 스레드의 차이](#프로세스와-스레드의-차이)
  * [Context-Switch](#Context-Switch)

## 컴파일러와 인터프리터의 차이

### 컴파일 (Compile)

프로그래밍 언어를 Runtime 이전에 기계어로 해석하는 작업 방식이다. 
이 때 원래의 소스를 원시 코드, 바뀐 코드를 목적 코드(Object Code)라 한다.
런타임 이전에 Assembly 언어로 변환하기 때문에 구동 시간이 오래걸리지만, 구동된 이후는 하나의 패키지로 매우 빠르게 작동한다.
구동 시에 코드와 함께 시스템으로부터 메모리를 할당받으며 할당받은 메모리를 사요하게 된다.
런타임 이전에 이미 해석을 마치고 대게 컴파일 결과물이 바로 기계어로 전환되기 때문에 **OS 및 빌드 환경에 종속적**이다.
그러므로 OS 환경에 맞체 호환되는 라이브러리와 빌드환경을 구분해서 구축해줘야 한다.

Compile 언어의 대표격으로 C/C++과 같은 언어를 들 수 있으며, Java 역시 Byte Code로 바꾸기 위한 과정에서 컴파일을 수행한다.

### 인터프릿 (Interpret)

런타임 이후에 Row 단위로 해석(Interpret)하며 프로그램을 구동시키는 방식이다.
프로그래밍 언어를 기계어로 바로 바꾸지 않고 중간 단계를 거친 뒤, 런타임에 즉시 해석하기 때문에 바로 컴팩트한 패키지 형태로 Binary file을 뽑아낼 수 있는
Compile 방식에 비해 낮은 퍼포먼스를 보이게 된다.
런타임에 직접 코드를 구동시키는 특징이 있기 때문에 실제 실행시간은 느리며, 대신 런타임에 실시간 Debugging 및 코드 수정이 가능하다.
또한 메모리를 별도로 할당받아 수행하지 않으며, 필요할 때 할당하여 사용한다. 
이와 관련하여 코드의 흐름 자체도 **실제 필요할 때, 실제 수행되어야 하는 시점에 수행**되기 때문에 덕타이핑(Duck Typing)이 가능한 측면이 있으나,
반대로 정적 분석이 되지 않는 Trade off를 갖고 있다.

Interpreter 언어의 대표격으로 Javascript와 같은 스크립팅 언어가 있다. 하지만, 스크립트 언어 뿐 아니라 컴파일 이후의 동작에서 Interpret을 수행하는 언어들도 많이 존재한다.


많은 프로그래밍 언어들의 인터프리터는 해석을 위한 Virtual Machine을 두고, Machine 위에서 Interpret을 수행하게 되는데, 이 때 해석의 기반이 되는 머신들이 OS 환경들을 지원해줌으로써,
해당 방식으로 인터프리터는 OS 및 플랫폼에 종속되지 않는 프로그램 구동이 가능하게 된다.
(이런 특징을 지닌 Interpreter는 Java의 JVM과 Python의 Analyzer가 있다.)

### 컴파일러와 인터프리터의 차이점
|        | 컴파일러 | 인터프리터|
|--------|---------|-----------|
|번역 단위| 전체 | 한줄씩 |
|실행 속도| 빠름 | 느림 |
|번역 속도| 느림 | 빠름 |
|목적 프로그램| 생성함 | 생성하지 않음 |
|메모리 할당| 목적 프로그램 생성시 사용| 사용 안함|

### 컴파일러 (Compiler)

컴파일러는 사람이 소스코드를 작성하면 그 소스코드를 한 번에 번역한다.
때문에 줄 단위로 번역을 진행하는 인터프리터에 비해 번역 시간이 오래 걸리고 그 과정이 복잡하다.
프로그래머가 코딩을 하다가 오류를 작성했을 때 전부 작성하고 실행파일을 만들어서 실행을 해봐야 알 수 있다.
하지만, 한 번 번역을 하면 실행파일(목적파일)이 생성 되어 메모리를 사용하지만 다음에 실행할 때는 이 파일만 실행하면 되기 때문에 실행 시간을 인터프리터에 비해 빠르다.

### 인터프리터 (Interpreter)

한 줄 한 줄, 줄 단위로 번역과 실행을 진행하기 때문에 번역 시간을 빠르지만 실행 시간은 느리다. 
직접 실행하기 때문에 실행 파일을 생성하지 않아 메모리는 사용하지 않는다.
줄 단위로 번역과 실행을 진행하기 때문에 중간에 문제 있는 코드를 만난 경우, 그 줄부터 아래는 실행되지 않는다.

#### 그럼 개발자는 인터프리터를 쓰는 게 좋은가?

**그렇지 않다.**
인터프리터의 경우 웹에서 많이 사용된다.
컴파일러로 웹을 작성할 경우 만약 중간에 오류를 유발하는 코드를 작성했거나 유지보수 하는 도중에 치명적인 오류를 발생하는 코드를 집어 넣었다면 그 웹은 아예 작동이 되지 않고 사용자가 볼 수 없게 된다.
하지만, 인터프리터를 사용하면 일정 부분이 오류를 내도 그 전까지는 작동이 되기 때문에 컴파일러에 비해서 손실을 줄일 수 있다.
또, 오류가 어디서 났는지 바로 확인 할 수 있기 때문에 유지보수가 유리하다.
하지만 실행속도가 느리기 때문에 퍼포먼스를 중요시한다면 컴파일러를 적용하는 것이 좋다.

</br>

---

## 컴파일러와 인터프리터의 차이


### 프로세스(Process)

프로세스를 이해하기 위해 먼저 프로그램(Program)과 비교하면 편하다.
```
#### 프로그램(Program)

실행 가능한 명령어(instruction)의 집합이다.
보통 디스크에 저장되어 바이너리 이미지 형태일 수도 있고, 파이썬 스크립트 같이 해석되는(Interpret) 고급어 형태일 수도 있다.
프로그램의 정의는 꽤나 포용적이기 때문에 컴퓨터에 설치된 포토샵 파일, 파이썬 구구단 출력 스크립트 파일 등이 모두 프로그램이 될 수 있다.
중요한 건 **디스크에 저장될 실행 가능한 명령어의 집합인지의 여부이다.**
```

프로세스는 **메모리에 적재(load)되어 실행되고 있는 프로그램**을 말한다. 정적인 프로그램과 달리 프로세스는 실제 실행 중인 프로그램을 일컫기 때문에 동적이라고 표현하기도 한다.
프로세스를 **프로그램의 인스턴스**라고 표현하기도 하는데, 프로그램을 실행하게 되면 CPU를 차지하면서 수행하는 수행 주체가 프로세스이기 때문이다.
프로그램은 하나지만, 이 프로그램을 실행하는 인스턴스는 여러 개가 생길 수 있다.
예를 들어, 한글 문서 편집할 때 한글 실행파일을 누르면 한글 창이 뜬다. 실행 파일은 한 개인데 한글 창은 여러 개 만들 수 있다.
새로 만들기 하면 한글 창이 하나 더 생겨 작업 표시줄에 한글이 두 개가 되어 동시 작업이 가능하다.
여기서 한글 실행파일이 프로그램, 한글 창은 프로세스이다. 즉, 프로그램을 실행시켜서 프로세스를 2개 만든다.

#### 프로세스 제어 블록(Process Control Block, PCB)

프로세스는 커널에 의해 직접 관리되는데, 커널 메모리 안에는 각 프로세스마다 관리하고 있는 프로세스에 대한 데이터들이 있다. 
PCB는 특정 **프로세스에 대한 중요한 정보를 저장**하고 있는 운영체제의 자료구조이다. 
운영체제는 프로세스를 관리하기 위해 **프로세스의 생성과 동시에 고유한 PCB를 생성**한다. 프로세스는 CPU를 할당받아 작업을 처리하다가도 프로세스 전환이 발생하면 진행하던 작업을 저장하고 CPU를 반환해야 하는데, 이 때 작업의 진행 상황을 모두 PCB에 저장한다. 그리고 다시 CPU를 할당받게 되면 PCB에 저장되어 있던 내용을 불러와 이전에 종료했던 시점부터 다시 작업을 수행한다.

_PCB에 저장되는 정보_

* 프로세스 식별자(Process ID, PID): 프로세스 식별 번호
* 프로세스 상태: new, ready, running, waiting, terminated 등의 상태를 저장
* 프로그램 카운터: 프로세스가 다음에 실행할 명령어의 주소
* CPU 레지스터
* CPU 스케쥴링 정보: 프로세스의 우선순위, 스케줄 큐에 대한 포인터 등
* 메모리 관리 정보: 페이지 테이블 또는 세그먼트 테이블 등과 같은 정보를 포함
* 입출력 상태 정보: 프로세스에 할당된 입출력 장치들과 열린 파일 목록
* 어카운팅 정보: 사용된 CPU 시간, 시간 제한, 계정 번호 등

![Process Control Block, PCB](https://gmlwjd9405.github.io/images/os-process-and-thread/process.png)
**커널 메모리 안에서 관리되는 PCB 정보가 아닌 유저가 사용하는 메모리 공간 상의 프로세스 정보는 4가지 분류**로 다시 나뉜다.
* Code(Text): 프로그램의 실제 코드를 저장
* Data: 프로세스가 실행될 때 정의된 전역 변수. static 변수들을 저장 (초기화된 데이터)
* Heap: 프로세스 런타임 중 동적으로 할당되는 변수들을 저장(함수 내에서 할당되는 변수 등 ex. new(), mallock())
* Stack: 함수에서 다른 함수를 실행하는 등의 서브루틴들의 정보를 저장(재귀와 스택이 관련 있는 이유)

_특징_
* 각각 독립된 메모리 영역(Code, Data, Stack, Heap의 구조)을 할당받는다.
* 기본적으로 프로세스당 최소 1개의 스레드(메인 스레드)를 가지고 있다.
* 각 프로세스는 별도의 주소 공간에서 실행되며, 한 프로세스는 다른 프로세스의 변수나 자료 구조에 접근할 수 없다.
* 한 프로세스가 다른 프로세스의 자원에 접근하려면 프로세스 간의 통신(IPC, inter-process communication)을 사용해야 한다.
  * ex. 파이프, 파일, 소켓 등을 이용한 통신 방법 이용

**운영체제는 각각의 프로세스는 독립적으로 관리하기 때문에 서로 다른 프로세스가 겹칠 일이 없고, 또 사용 자원 영역 등이 겹치는 일이 발생해서도 안 된다.** 
다만, **한 가지 예외로 같은 프로그램의 프로세스들은 Code 영역은 공유한다.**
내용이 동일한 프로그램의 코드를 여러 개 복사해서 프로세스마다 가지고 있는 것보다는 메모리 상의 코드 공간을 주소로 참조하는 것이 낫기 때문이다.

</br>

### 스레드(Thread)

스레드는 프로세스의 실행 단위라고 할 수 있다. 한 프로세스 내에서 동작되는 여러 실행 흐름으로 프로세스 내의 주소 공간이나 자원을 공유할 수 있다. 
기본적으로 하나의 프로세스가 생성되면 하나의 스레드가 같이 생성된다. 이를 메인 스레드라고 부르며, 스레드를 추가로 생성하지 않는 한 모든 프로그램 코드는 여러 개의 스레드를 가질 수 있으며 이를 멀티스레드라고 한다.

#### 스레드를 사용할 때의 장점
* 프로세스간 통신에 비해 스레드 간 통신이 훨씬 간단하다.
  * 서로 공유하는 변수를 변경하기만 하면 되기 때문이다. 
* 시스템의 자원 소모가 줄어든다.
  * 기존 프로세스의 자원을 다른 스레드와 공유하기 때문에 자원을 새로 할당하지 않아도 된다.
* 전체 응답 시간이 단축된다.
  * 시간도 자원이기 때문에, 오버헤드가 줄어들어 전체 응답이 짧아진다. 또, 병목이 걸리는 작업과 다른 작업을 구분할 수 있어 전체 실행시간을 줄일 수 있다.

**위와 같은 장점이 왜 웹 서버가 각각의 HTTP 통신을 멀티프로세스가 아닌 멀티스레드로 구현하는지를 설명한다.**

하지만, 스레드를 사용할 때의 단점도 있다.
* 여러 스레드를 이용하는 프로그램을 작성하는 경우, 설계를 신경써야 한다. 미묘한 시간 차나 잘못된 변수를 공유함으로써 문제가 발생할 수 있다.
* 디버깅이 어렵다.

![멀티스레드의 구조](https://gmlwjd9405.github.io/images/os-process-and-thread/thread.png)
**Code, Data, Heap 영역을 공유하고 있으며, Stack만 스레드 별로 가진다.**
```
#### 굳이 스택만 분리해서 사용하는 이유는?
LIFO(Last In First Out) 특징과 관련있다.
왜냐하면? 스택 영역은 스택이 쌓이면 위에서부터 프로세스가 섞인 채로 순서대로 나오게 되므로 더 복잡해지기 때문에 원활한 실행 흐름을 위해
스택은 따로 독립적으로 존재하게 된다.
```

### 프로세스와 스레드의 차이점
|        | 프로세스 | 스레드 |
|--------|---------|-----------|
|자원 할당 여부| 실행 시마다 새로운 자원을 할당 | 자신을 실행한 프로세스의 자원을 공유 |
|자원 공유 여부| 일반적으로 자원을 공유하지 않음. 같은 프로그램의 프로세스일 경우 코드를 공유하기는 함. | 같은 프로세스 내 스레드들은 스택을 제외한 나머지 세 영역을 공유 |
|독립성 여부| 일반적으로 독립적 | 일반적으로 프로세스의 하위 집합 |
|주소 소유 여부| 별개의 주소 공간을 가짐 | 주소 공간을 공유 |
|통신 여부| 오직 시스템이 제공하는 IPC 방법으로만 통신 | 공유 변수 수정 등 자유롭게 다른 스레드와 소통 |
